// This file was generated by Peginator v0.6.0 built at 1672439020
// CRC-32/ISO-HDLC of the grammar file: ead6f8c4
// Any changes to it will be lost on regeneration

# [derive (Debug , Clone ,)] pub struct Program { pub body : Block , } # [derive (Debug , Clone ,)] pub struct Block { pub statements : Vec < Statement > , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum Statement { Assignment (Assignment) , EndStatement (EndStatement) , ForStatement (ForStatement) , PrintStatement (PrintStatement) , } # [derive (Debug , Clone ,)] pub struct NewLine ; # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum Expression { Add (Add) , Sub (Sub) , Term (Term) , } # [derive (Debug , Clone ,)] pub struct Add { pub left : Box < Expression > , pub right : Term , } # [derive (Debug , Clone ,)] pub struct Sub { pub left : Box < Expression > , pub right : Term , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum Term { Div (Div) , Factor (Factor) , Mul (Mul) , } # [derive (Debug , Clone ,)] pub struct Mul { pub left : Box < Term > , pub right : Factor , } # [derive (Debug , Clone ,)] pub struct Div { pub left : Box < Term > , pub right : Factor , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum Factor { Group (Group) , NumberLiteral (NumberLiteral) , Variable (Variable) , } # [derive (Debug , Clone ,)] pub struct Group { pub body : Box < Expression > , } # [derive (Debug , Clone ,)] pub struct Assignment { pub variable : Variable , pub value : Assignment_value , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum Assignment_value { Expression (Expression) , StringLiteral (StringLiteral) , } # [derive (Debug , Clone ,)] pub struct PrintStatement { pub list : Vec < PrintListItem > , } # [derive (Debug , Clone ,)] pub struct PrintSkipNl ; # [derive (Debug , Clone ,)] pub struct PrintListItem { pub value : PrintListItem_value , pub sep : Option < PrintListSep > , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum PrintListItem_value { Expression (Expression) , StringLiteral (StringLiteral) , } # [derive (Debug , Clone ,)] pub struct PrintListSep ; # [derive (Debug , Clone ,)] pub struct ForStatement { pub assignment : Assignment , pub target : Expression , pub step : Option < ForStep > , pub body : Block , pub next : ForNext , } # [derive (Debug , Clone ,)] pub struct ForStep { pub value : Expression , } # [derive (Debug , Clone ,)] pub struct ForNext ; # [derive (Debug , Clone ,)] pub struct EndStatement ; # [derive (Debug , Clone ,)] pub struct KWPrint ; # [derive (Debug , Clone ,)] pub struct KWFor ; # [derive (Debug , Clone ,)] pub struct KWTo ; # [derive (Debug , Clone ,)] pub struct KWStep ; # [derive (Debug , Clone ,)] pub struct KWNext ; # [derive (Debug , Clone ,)] pub struct KWEnd ; # [derive (Debug , Clone ,)] pub struct Variable { pub name : VariableName , } pub type VariableName = String ; # [derive (Debug , Clone ,)] pub struct NumberSign ; # [derive (Debug , Clone ,)] pub struct NumberLiteral { pub value : NumberLiteral_value , } # [allow (non_camel_case_types)] # [derive (Debug , Clone ,)] pub enum NumberLiteral_value { FloatLiteral (FloatLiteral) , IntegerLiteral (IntegerLiteral) , } pub type IntegerLiteral = String ; pub type FloatLiteral = String ; # [derive (Debug , Clone ,)] pub struct StringLiteral { pub body : StringBody , } pub type StringBody = String ; # [derive (Debug , Clone ,)] pub struct ALPHA ; # [derive (Debug , Clone ,)] pub struct DIGIT ; # [derive (Debug , Clone ,)] pub struct Whitespace ; impl peginator_generated :: PegParserAdvanced < () > for Program { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_Program (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } impl peginator_generated :: PegParserAdvanced < () > for Expression { fn parse_advanced < TT : peginator_generated :: ParseTracer > (s : & str , settings : & peginator_generated :: ParseSettings , user_context : () ,) -> Result < Self , peginator_generated :: ParseError > { Ok (peginator_generated :: parse_Expression (peginator_generated :: ParseState :: new (s , settings) , & mut peginator_generated :: ParseGlobal :: < TT , peginator_generated :: ParseCache , () > :: new (Default :: default () , user_context ,) ,) ? . result) } } # [allow (non_snake_case , unused_variables , unused_imports , unused_mut , dead_code ,)] mod peginator_generated { use super :: * ; pub use peginator :: { ParseError , ParseSettings , ParseState , PegParser , IndentedTracer , ParseTracer , PegPosition , ParseGlobal , PegParserAdvanced , } ; use peginator :: * ; # [derive (Default)] pub struct ParseCache < 'a > { pub c_Expression : CacheEntries < 'a , Expression > , pub c_Term : CacheEntries < 'a , Term > , pub c_Factor : CacheEntries < 'a , Factor > , _please_dont_complain : std :: marker :: PhantomData < & 'a () > , } mod Program_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : body , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Block (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_end_of_input (state ,) }) ? ; Ok (ParseOk { result : body , state }) } pub type Parsed = Block ; } # [inline] pub (super) fn parse_Program < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Program > { global . tracer . print_trace_start (& state , "Program") ; let result = (|| { let result = Program_impl :: parse (state , global) ? . map (| r | super :: Program { body : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Block_impl { use super :: * ; mod part_0 { use super :: * ; mod closure { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NewLine (state , & mut * global) }) . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut statements , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Statement (state , & mut * global) }) . map_inner (| result | vec ! [result]) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : statements , state }) } pub type Parsed = Vec < Statement > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut statements : Vec < Statement > = Vec :: new () ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { statements . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : statements , state }) } pub type Parsed = Vec < Statement > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : mut statements , state } = part_0 :: parse (state , global) ? ; let ParseOk { result : extend_statements_with , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Statement (state , & mut * global) }) . map_inner (| result | vec ! [result]) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; statements . extend (extend_statements_with) ; Ok (ParseOk { result : statements , state }) } pub type Parsed = Vec < Statement > ; } # [inline] pub (super) fn parse_Block < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Block > { global . tracer . print_trace_start (& state , "Block") ; let result = (|| { let result = Block_impl :: parse (state , global) ? . map (| r | super :: Block { statements : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Statement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ForStatement (state , global) }) . map_inner (Parsed__override :: ForStatement)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PrintStatement (state , global) }) . map_inner (Parsed__override :: PrintStatement)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_EndStatement (state , global) }) . map_inner (Parsed__override :: EndStatement)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Assignment (state , global) }) . map_inner (Parsed__override :: Assignment)) . end () } pub type Parsed = Parsed__override ; use super :: Statement as Parsed__override ; } # [inline] pub (super) fn parse_Statement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Statement > { global . tracer . print_trace_start (& state , "Statement") ; let result = (|| { let result = Statement_impl :: parse (state , global) ? ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NewLine_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '\n') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NewLine < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NewLine > { global . tracer . print_trace_start (& state , "NewLine") ; let result = (|| { let result = NewLine_impl :: parse (state , global) ? . map (| r | super :: NewLine { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Expression_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Add (state , global) }) . map_inner (Parsed__override :: Add)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Sub (state , global) }) . map_inner (Parsed__override :: Sub)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Term (state , global) }) . map_inner (Parsed__override :: Term)) . end () } pub type Parsed = Parsed__override ; use super :: Expression as Parsed__override ; } # [inline] pub (super) fn parse_Expression < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Expression > { global . tracer . print_trace_start (& state , "Expression") ; let result = (|| { let cache_key = state . cache_key () ; if let Some (cached) = global . cache . c_Expression . get (& cache_key) { global . tracer . print_informative ("Cache hit (left recursive)") ; cached . clone () } else { let mut best_result = Err (state . clone () . report_error (ParseErrorSpecifics :: LeftRecursionSentinel)) ; global . cache . c_Expression . insert (cache_key , best_result . clone ()) ; loop { global . tracer . print_informative ("Starting new left recursive loop") ; let state = state . clone () ; let new_result = { let result = Expression_impl :: parse (state , global) ? ; Ok (result) } ; match (new_result , & best_result) { (Ok (nro) , Ok (bro)) => { if nro . state . is_further_than (& bro . state) { best_result = Ok (nro) ; global . cache . c_Expression . insert (cache_key , best_result . clone ()) ; } else { break ; } } (Ok (nro) , Err (bre)) => { best_result = Ok (nro) ; global . cache . c_Expression . insert (cache_key , best_result . clone ()) ; } (Err (nre) , Ok (bro)) => { break ; } (Err (nre) , Err (bre)) => { best_result = Err (nre) ; global . cache . c_Expression . insert (cache_key , best_result . clone ()) ; break ; } } } best_result } }) () ; global . tracer . print_trace_result (& result) ; result } mod Add_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : left , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Expression (state , & mut * global) }) . map_inner (Box :: new) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '+') }) . discard_result () ? ; let ParseOk { result : right , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Term (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { left , right , } , state }) } pub struct Parsed { pub left : Box < Expression > , pub right : Term , } } # [inline] pub (super) fn parse_Add < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Add > { global . tracer . print_trace_start (& state , "Add") ; let result = (|| { let result = Add_impl :: parse (state , global) ? . map (| r | super :: Add { left : r . left , right : r . right , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Sub_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : left , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Expression (state , & mut * global) }) . map_inner (Box :: new) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '-') }) . discard_result () ? ; let ParseOk { result : right , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Term (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { left , right , } , state }) } pub struct Parsed { pub left : Box < Expression > , pub right : Term , } } # [inline] pub (super) fn parse_Sub < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Sub > { global . tracer . print_trace_start (& state , "Sub") ; let result = (|| { let result = Sub_impl :: parse (state , global) ? . map (| r | super :: Sub { left : r . left , right : r . right , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Term_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Mul (state , global) }) . map_inner (Parsed__override :: Mul)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Div (state , global) }) . map_inner (Parsed__override :: Div)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Factor (state , global) }) . map_inner (Parsed__override :: Factor)) . end () } pub type Parsed = Parsed__override ; use super :: Term as Parsed__override ; } # [inline] pub (super) fn parse_Term < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Term > { global . tracer . print_trace_start (& state , "Term") ; let result = (|| { let cache_key = state . cache_key () ; if let Some (cached) = global . cache . c_Term . get (& cache_key) { global . tracer . print_informative ("Cache hit (left recursive)") ; cached . clone () } else { let mut best_result = Err (state . clone () . report_error (ParseErrorSpecifics :: LeftRecursionSentinel)) ; global . cache . c_Term . insert (cache_key , best_result . clone ()) ; loop { global . tracer . print_informative ("Starting new left recursive loop") ; let state = state . clone () ; let new_result = { let result = Term_impl :: parse (state , global) ? ; Ok (result) } ; match (new_result , & best_result) { (Ok (nro) , Ok (bro)) => { if nro . state . is_further_than (& bro . state) { best_result = Ok (nro) ; global . cache . c_Term . insert (cache_key , best_result . clone ()) ; } else { break ; } } (Ok (nro) , Err (bre)) => { best_result = Ok (nro) ; global . cache . c_Term . insert (cache_key , best_result . clone ()) ; } (Err (nre) , Ok (bro)) => { break ; } (Err (nre) , Err (bre)) => { best_result = Err (nre) ; global . cache . c_Term . insert (cache_key , best_result . clone ()) ; break ; } } } best_result } }) () ; global . tracer . print_trace_result (& result) ; result } mod Mul_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : left , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Term (state , & mut * global) }) . map_inner (Box :: new) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '*') }) . discard_result () ? ; let ParseOk { result : right , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Factor (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { left , right , } , state }) } pub struct Parsed { pub left : Box < Term > , pub right : Factor , } } # [inline] pub (super) fn parse_Mul < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Mul > { global . tracer . print_trace_start (& state , "Mul") ; let result = (|| { let result = Mul_impl :: parse (state , global) ? . map (| r | super :: Mul { left : r . left , right : r . right , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Div_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : left , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Term (state , & mut * global) }) . map_inner (Box :: new) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '/') }) . discard_result () ? ; let ParseOk { result : right , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Factor (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { left , right , } , state }) } pub struct Parsed { pub left : Box < Term > , pub right : Factor , } } # [inline] pub (super) fn parse_Div < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Div > { global . tracer . print_trace_start (& state , "Div") ; let result = (|| { let result = Div_impl :: parse (state , global) ? . map (| r | super :: Div { left : r . left , right : r . right , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Factor_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Group (state , global) }) . map_inner (Parsed__override :: Group)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NumberLiteral (state , global) }) . map_inner (Parsed__override :: NumberLiteral)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Variable (state , global) }) . map_inner (Parsed__override :: Variable)) . end () } pub type Parsed = Parsed__override ; use super :: Factor as Parsed__override ; } # [inline] pub (super) fn parse_Factor < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Factor > { global . tracer . print_trace_start (& state , "Factor") ; let result = (|| { let cache_key = state . cache_key () ; if let Some (cached) = global . cache . c_Factor . get (& cache_key) { global . tracer . print_informative ("Cache hit") ; cached . clone () } else { let result = { let result = Factor_impl :: parse (state , global) ? ; Ok (result) } ; global . cache . c_Factor . insert (cache_key , result . clone ()) ; result } }) () ; global . tracer . print_trace_result (& result) ; result } mod Group_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '(') }) . discard_result () ? ; let ParseOk { result : body , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Expression (state , & mut * global) }) . map_inner (Box :: new) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ')') }) . discard_result () ? ; Ok (ParseOk { result : body , state }) } pub type Parsed = Box < Expression > ; } # [inline] pub (super) fn parse_Group < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Group > { global . tracer . print_trace_start (& state , "Group") ; let result = (|| { let result = Group_impl :: parse (state , global) ? . map (| r | super :: Group { body : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Assignment_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : variable , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Variable (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '=') }) . discard_result () ? ; let ParseOk { result : value , state } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Expression (state , & mut * global) }) . map_inner (Parsed_value :: Expression)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_StringLiteral (state , & mut * global) }) . map_inner (Parsed_value :: StringLiteral)) . end () ? ; Ok (ParseOk { result : Parsed { variable , value , } , state }) } pub struct Parsed { pub variable : Variable , pub value : Parsed_value , } use super :: Assignment_value as Parsed_value ; } # [inline] pub (super) fn parse_Assignment < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Assignment > { global . tracer . print_trace_start (& state , "Assignment") ; let result = (|| { let result = Assignment_impl :: parse (state , global) ? . map (| r | super :: Assignment { variable : r . variable , value : r . value , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PrintStatement_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; let mut list : Vec < PrintListItem > = Vec :: new () ; loop { match parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PrintListItem (state , & mut * global) }) . map_inner (| result | vec ! [result]) { Ok (ParseOk { result : __result , state : new_state , .. }) => { list . extend (__result) ; state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : list , state }) } pub type Parsed = Vec < PrintListItem > ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KWPrint (state , & mut * global) }) . discard_result () ? ; let ParseOk { result : mut list , state } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : list , state }) } pub type Parsed = Vec < PrintListItem > ; } # [inline] pub (super) fn parse_PrintStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PrintStatement > { global . tracer . print_trace_start (& state , "PrintStatement") ; let result = (|| { let result = PrintStatement_impl :: parse (state , global) ? . map (| r | super :: PrintStatement { list : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PrintSkipNl_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ';') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PrintSkipNl < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PrintSkipNl > { global . tracer . print_trace_start (& state , "PrintSkipNl") ; let result = (|| { let result = PrintSkipNl_impl :: parse (state , global) ? . map (| r | super :: PrintSkipNl { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PrintListItem_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { result : value , state } = ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Expression (state , & mut * global) }) . map_inner (Parsed_value :: Expression)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_StringLiteral (state , & mut * global) }) . map_inner (Parsed_value :: StringLiteral)) . end () ? ; let ParseOk { result : sep , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_PrintListSep (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : Parsed { value , sep , } , state }) } pub struct Parsed { pub value : Parsed_value , pub sep : Option < PrintListSep > , } use super :: PrintListItem_value as Parsed_value ; } # [inline] pub (super) fn parse_PrintListItem < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PrintListItem > { global . tracer . print_trace_start (& state , "PrintListItem") ; let result = (|| { let result = PrintListItem_impl :: parse (state , global) ? . map (| r | super :: PrintListItem { value : r . value , sep : r . sep , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod PrintListSep_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , ';') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_PrintListSep < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , PrintListSep > { global . tracer . print_trace_start (& state , "PrintListSep") ; let result = (|| { let result = PrintListSep_impl :: parse (state , global) ? . map (| r | super :: PrintListSep { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ForStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KWFor (state , & mut * global) }) . discard_result () ? ; let ParseOk { result : assignment , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Assignment (state , & mut * global) }) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KWTo (state , & mut * global) }) . discard_result () ? ; let ParseOk { result : target , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Expression (state , & mut * global) }) ? ; let ParseOk { result : step , state } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ForStep (state , & mut * global) }) . map_inner (Some) . or_else (| err | Ok (ParseOk { result : Default :: default () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_NewLine (state , & mut * global) }) . discard_result () ? ; let ParseOk { result : body , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Block (state , & mut * global) }) ? ; let ParseOk { result : next , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_ForNext (state , & mut * global) }) ? ; Ok (ParseOk { result : Parsed { assignment , target , step , body , next , } , state }) } pub struct Parsed { pub assignment : Assignment , pub target : Expression , pub step : Option < ForStep > , pub body : Block , pub next : ForNext , } } # [inline] pub (super) fn parse_ForStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ForStatement > { global . tracer . print_trace_start (& state , "ForStatement") ; let result = (|| { let result = ForStatement_impl :: parse (state , global) ? . map (| r | super :: ForStatement { assignment : r . assignment , target : r . target , step : r . step , body : r . body , next : r . next , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ForStep_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KWStep (state , & mut * global) }) . discard_result () ? ; let ParseOk { result : value , state } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Expression (state , & mut * global) }) ? ; Ok (ParseOk { result : value , state }) } pub type Parsed = Expression ; } # [inline] pub (super) fn parse_ForStep < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ForStep > { global . tracer . print_trace_start (& state , "ForStep") ; let result = (|| { let result = ForStep_impl :: parse (state , global) ? . map (| r | super :: ForStep { value : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ForNext_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KWNext (state , & mut * global) }) . discard_result () ? ; let ParseOk { state , .. } = parse_Whitespace (state . clone () , & mut * global) . and_then (| ParseOk { state , .. } | { parse_Variable (state , & mut * global) }) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_ForNext < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ForNext > { global . tracer . print_trace_start (& state , "ForNext") ; let result = (|| { let result = ForNext_impl :: parse (state , global) ? . map (| r | super :: ForNext { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod EndStatement_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_KWEnd (state , & mut * global) }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_EndStatement < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , EndStatement > { global . tracer . print_trace_start (& state , "EndStatement") ; let result = (|| { let result = EndStatement_impl :: parse (state , global) ? . map (| r | super :: EndStatement { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod KWPrint_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "PRINT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_KWPrint < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , KWPrint > { global . tracer . print_trace_start (& state , "KWPrint") ; let result = (|| { let result = KWPrint_impl :: parse (state , global) ? . map (| r | super :: KWPrint { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod KWFor_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "FOR") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_KWFor < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , KWFor > { global . tracer . print_trace_start (& state , "KWFor") ; let result = (|| { let result = KWFor_impl :: parse (state , global) ? . map (| r | super :: KWFor { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod KWTo_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "TO") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_KWTo < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , KWTo > { global . tracer . print_trace_start (& state , "KWTo") ; let result = (|| { let result = KWTo_impl :: parse (state , global) ? . map (| r | super :: KWTo { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod KWStep_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "STEP") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_KWStep < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , KWStep > { global . tracer . print_trace_start (& state , "KWStep") ; let result = (|| { let result = KWStep_impl :: parse (state , global) ? . map (| r | super :: KWStep { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod KWNext_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "NEXT") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_KWNext < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , KWNext > { global . tracer . print_trace_start (& state , "KWNext") ; let result = (|| { let result = KWNext_impl :: parse (state , global) ? . map (| r | super :: KWNext { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod KWEnd_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_string_literal (state , "END") }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_KWEnd < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , KWEnd > { global . tracer . print_trace_start (& state , "KWEnd") ; let result = (|| { let result = KWEnd_impl :: parse (state , global) ? . map (| r | super :: KWEnd { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Variable_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_VariableName (state , & mut * global) }) } pub type Parsed = VariableName ; } # [inline] pub (super) fn parse_Variable < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Variable > { global . tracer . print_trace_start (& state , "Variable") ; let result = (|| { let result = Variable_impl :: parse (state , global) ? . map (| r | super :: Variable { name : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod VariableName_impl { use super :: * ; mod part_0 { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_character_range (state , 'a' , 'z') . discard_result ()) . choice (| state | parse_character_range (state , 'A' , 'Z') . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | parse_character_literal (state , '_') . discard_result ()) . choice (| state | parse_character_literal (state , '`') . discard_result ()) . end () } pub type Parsed = () ; } mod part_1 { use super :: * ; mod closure { use super :: * ; mod choice_0 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_character_range (state , 'a' , 'z') . discard_result ()) . choice (| state | parse_character_range (state , 'A' , 'Z') . discard_result ()) . end () } pub type Parsed = () ; } mod choice_1 { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_character_range (state , '0' , '9') . discard_result () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | choice_0 :: parse (state , global)) . choice (| state | choice_1 :: parse (state , global)) . choice (| state | parse_character_literal (state , '_') . discard_result ()) . choice (| state | parse_character_literal (state , '%') . discard_result ()) . choice (| state | parse_character_literal (state , '$') . discard_result ()) . end () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_VariableName < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , VariableName > { global . tracer . print_trace_start (& state , "VariableName") ; let result = (|| { let result = VariableName_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NumberSign_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '+') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_literal (state , '-') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_NumberSign < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NumberSign > { global . tracer . print_trace_start (& state , "NumberSign") ; let result = (|| { let result = NumberSign_impl :: parse (state , global) ? . map (| r | super :: NumberSign { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod NumberLiteral_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_FloatLiteral (state , & mut * global) }) . map_inner (Parsed_value :: FloatLiteral)) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_IntegerLiteral (state , & mut * global) }) . map_inner (Parsed_value :: IntegerLiteral)) . end () } pub type Parsed = Parsed_value ; use super :: NumberLiteral_value as Parsed_value ; } # [inline] pub (super) fn parse_NumberLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , NumberLiteral > { global . tracer . print_trace_start (& state , "NumberLiteral") ; let result = (|| { let result = NumberLiteral_impl :: parse (state , global) ? . map (| r | super :: NumberLiteral { value : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod IntegerLiteral_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_character_range (state . clone () , '0' , '9') . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_NumberSign (state . clone () , & mut * global) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_IntegerLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , IntegerLiteral > { global . tracer . print_trace_start (& state , "IntegerLiteral") ; let result = (|| { let result = IntegerLiteral_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod FloatLiteral_impl { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_character_range (state , '0' , '9') . discard_result () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod part_3 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_character_range (state , '0' , '9') . discard_result () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } mod part_4 { use super :: * ; mod optional { use super :: * ; mod part_1 { use super :: * ; mod closure { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_character_range (state , '0' , '9') . discard_result () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } if iterations == 0 { return Err (state . report_farthest_error ()) ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_character_literal (state , 'E') . discard_result () ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { optional :: parse (state . clone () , global) . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_NumberSign (state . clone () , & mut * global) . discard_result () . or_else (| err | Ok (ParseOk { result : () , state : state . record_error (err) , })) ? ; let ParseOk { state , .. } = part_1 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_character_literal (state , '.') . discard_result () ? ; let ParseOk { state , .. } = part_3 :: parse (state , global) ? ; let ParseOk { state , .. } = part_4 :: parse (state , global) ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_FloatLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , FloatLiteral > { global . tracer . print_trace_start (& state , "FloatLiteral") ; let result = (|| { let result = FloatLiteral_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod StringLiteral_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = parse_character_literal (state , '"') . discard_result () ? ; let ParseOk { result : body , state } = parse_StringBody (state , & mut * global) ? ; let ParseOk { state , .. } = parse_character_literal (state , '"') . discard_result () ? ; Ok (ParseOk { result : body , state }) } pub type Parsed = StringBody ; } # [inline] pub (super) fn parse_StringLiteral < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , StringLiteral > { global . tracer . print_trace_start (& state , "StringLiteral") ; let result = (|| { let result = StringLiteral_impl :: parse (state , global) ? . map (| r | super :: StringLiteral { body : r , }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod StringBody_impl { use super :: * ; mod closure { use super :: * ; mod part_0 { use super :: * ; mod negative_lookahead { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_character_literal (state , '"') . discard_result () } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { match negative_lookahead :: parse (state . clone () , global) { Ok (_) => Err (state . report_error (ParseErrorSpecifics :: NegativeLookaheadFailed)) , Err (_) => Ok (ParseOk { result : () , state }) , } } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let ParseOk { state , .. } = part_0 :: parse (state , global) ? ; let ParseOk { state , .. } = parse_char (state , & mut * global) . discard_result () ? ; Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match closure :: parse (state . clone () , global) { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_StringBody < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , StringBody > { global . tracer . print_trace_start (& state , "StringBody") ; let result = (|| { let result = StringBody_impl :: parse (state . clone () , global) ? . map_with_state (| _ , new_state | { let string = state . slice_until (new_state) . to_string () ; string }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod ALPHA_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { ChoiceHelper :: new (state) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , 'a' , 'z') }) . discard_result ()) . choice (| state | parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , 'A' , 'Z') }) . discard_result ()) . end () } pub type Parsed = () ; } # [inline] pub (super) fn parse_ALPHA < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , ALPHA > { global . tracer . print_trace_start (& state , "ALPHA") ; let result = (|| { let result = ALPHA_impl :: parse (state , global) ? . map (| r | super :: ALPHA { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod DIGIT_impl { use super :: * ; # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { parse_Whitespace (state , & mut * global) . and_then (| ParseOk { state , .. } | { parse_character_range (state , '0' , '9') }) . discard_result () } pub type Parsed = () ; } # [inline] pub (super) fn parse_DIGIT < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , DIGIT > { global . tracer . print_trace_start (& state , "DIGIT") ; let result = (|| { let result = DIGIT_impl :: parse (state , global) ? . map (| r | super :: DIGIT { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } mod Whitespace_impl { use super :: * ; mod closure { use super :: * ; } # [inline (always)] pub fn parse < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Parsed > { let mut iterations : usize = 0 ; let mut state = state ; loop { match parse_character_literal (state . clone () , ' ') . discard_result () { Ok (ParseOk { result : __result , state : new_state , .. }) => { state = new_state ; } , Err (err) => { state = state . record_error (err) ; break ; } } iterations += 1 ; } Ok (ParseOk { result : () , state }) } pub type Parsed = () ; } # [inline] pub (super) fn parse_Whitespace < 'a , TT : ParseTracer > (state : ParseState < 'a > , global : & mut ParseGlobal < TT , ParseCache < 'a > , () > ,) -> ParseResult < 'a , Whitespace > { global . tracer . print_trace_start (& state , "Whitespace") ; let result = (|| { let result = Whitespace_impl :: parse (state , global) ? . map (| r | super :: Whitespace { }) ; Ok (result) }) () ; global . tracer . print_trace_result (& result) ; result } }
